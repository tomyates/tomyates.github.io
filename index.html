<!doctype html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="apple-mobile-web-app-capable" content="yes"/><title>CrowdSurf</title><script>var _rollbarConfig = {
      accessToken: "7615dc5a0b0b437690dac53069cc18e5",
      captureUncaught: true,
      captureUnhandledRejections: true,
      payload: {
        environment: "production"
      }
    };
    // Rollbar Snippet
    !function (r) { var e = {}; function o(n) { if (e[n]) return e[n].exports; var t = e[n] = { i: n, l: !1, exports: {} }; return r[n].call(t.exports, t, t.exports, o), t.l = !0, t.exports } o.m = r, o.c = e, o.d = function (r, e, n) { o.o(r, e) || Object.defineProperty(r, e, { enumerable: !0, get: n }) }, o.r = function (r) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r, "__esModule", { value: !0 }) }, o.t = function (r, e) { if (1 & e && (r = o(r)), 8 & e) return r; if (4 & e && "object" == typeof r && r && r.__esModule) return r; var n = Object.create(null); if (o.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: r }), 2 & e && "string" != typeof r) for (var t in r) o.d(n, t, function (e) { return r[e] }.bind(null, t)); return n }, o.n = function (r) { var e = r && r.__esModule ? function () { return r.default } : function () { return r }; return o.d(e, "a", e), e }, o.o = function (r, e) { return Object.prototype.hasOwnProperty.call(r, e) }, o.p = "", o(o.s = 0) }([function (r, e, o) { "use strict"; var n = o(1), t = o(5); _rollbarConfig = _rollbarConfig || {}, _rollbarConfig.rollbarJsUrl = _rollbarConfig.rollbarJsUrl || "https://cdn.rollbar.com/rollbarjs/refs/tags/v2.25.2/rollbar.min.js", _rollbarConfig.async = void 0 === _rollbarConfig.async || _rollbarConfig.async; var a = n.setupShim(window, _rollbarConfig), l = t(_rollbarConfig); window.rollbar = n.Rollbar, a.loadFull(window, document, !_rollbarConfig.async, _rollbarConfig, l) }, function (r, e, o) { "use strict"; var n = o(2), t = o(3); function a(r) { return function () { try { return r.apply(this, arguments) } catch (r) { try { console.error("[Rollbar]: Internal error", r) } catch (r) { } } } } var l = 0; function i(r, e) { this.options = r, this._rollbarOldOnError = null; var o = l++; this.shimId = function () { return o }, "undefined" != typeof window && window._rollbarShims && (window._rollbarShims[o] = { handler: e, messages: [] }) } var s = o(4), d = function (r, e) { return new i(r, e) }, c = function (r) { return new s(d, r) }; function u(r) { return a((function () { var e = this, o = Array.prototype.slice.call(arguments, 0), n = { shim: e, method: r, args: o, ts: new Date }; window._rollbarShims[this.shimId()].messages.push(n) })) } i.prototype.loadFull = function (r, e, o, n, t) { var l = !1, i = e.createElement("script"), s = e.getElementsByTagName("script")[0], d = s.parentNode; i.crossOrigin = "", i.src = n.rollbarJsUrl, o || (i.async = !0), i.onload = i.onreadystatechange = a((function () { if (!(l || this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState)) { i.onload = i.onreadystatechange = null; try { d.removeChild(i) } catch (r) { } l = !0, function () { var e; if (void 0 === r._rollbarDidLoad) { e = new Error("rollbar.js did not load"); for (var o, n, a, l, i = 0; o = r._rollbarShims[i++];)for (o = o.messages || []; n = o.shift();)for (a = n.args || [], i = 0; i < a.length; ++i)if ("function" == typeof (l = a[i])) { l(e); break } } "function" == typeof t && t(e) }() } })), d.insertBefore(i, s) }, i.prototype.wrap = function (r, e, o) { try { var n; if (n = "function" == typeof e ? e : function () { return e || {} }, "function" != typeof r) return r; if (r._isWrap) return r; if (!r._rollbar_wrapped && (r._rollbar_wrapped = function () { o && "function" == typeof o && o.apply(this, arguments); try { return r.apply(this, arguments) } catch (o) { var e = o; throw e && ("string" == typeof e && (e = new String(e)), e._rollbarContext = n() || {}, e._rollbarContext._wrappedSource = r.toString(), window._rollbarWrappedError = e), e } }, r._rollbar_wrapped._isWrap = !0, r.hasOwnProperty)) for (var t in r) r.hasOwnProperty(t) && (r._rollbar_wrapped[t] = r[t]); return r._rollbar_wrapped } catch (e) { return r } }; for (var p = "log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleAnonymousErrors,handleUnhandledRejection,captureEvent,captureDomContentLoaded,captureLoad".split(","), f = 0; f < p.length; ++f)i.prototype[p[f]] = u(p[f]); r.exports = { setupShim: function (r, e) { if (r) { var o = e.globalAlias || "Rollbar"; if ("object" == typeof r[o]) return r[o]; r._rollbarShims = {}, r._rollbarWrappedError = null; var l = new c(e); return a((function () { e.captureUncaught && (l._rollbarOldOnError = r.onerror, n.captureUncaughtExceptions(r, l, !0), e.wrapGlobalEventHandlers && t(r, l, !0)), e.captureUnhandledRejections && n.captureUnhandledRejections(r, l, !0); var a = e.autoInstrument; return !1 !== e.enabled && (void 0 === a || !0 === a || function (r) { return !("object" != typeof r || void 0 !== r.page && !r.page) }(a)) && r.addEventListener && (r.addEventListener("load", l.captureLoad.bind(l)), r.addEventListener("DOMContentLoaded", l.captureDomContentLoaded.bind(l))), r[o] = l, l }))() } }, Rollbar: c } }, function (r, e, o) { "use strict"; function n(r, e, o, n) { r._rollbarWrappedError && (n[4] || (n[4] = r._rollbarWrappedError), n[5] || (n[5] = r._rollbarWrappedError._rollbarContext), r._rollbarWrappedError = null); var t = e.handleUncaughtException.apply(e, n); o && o.apply(r, n), "anonymous" === t && (e.anonymousErrorsPending += 1) } r.exports = { captureUncaughtExceptions: function (r, e, o) { if (r) { var t; if ("function" == typeof e._rollbarOldOnError) t = e._rollbarOldOnError; else if (r.onerror) { for (t = r.onerror; t._rollbarOldOnError;)t = t._rollbarOldOnError; e._rollbarOldOnError = t } e.handleAnonymousErrors(); var a = function () { var o = Array.prototype.slice.call(arguments, 0); n(r, e, t, o) }; o && (a._rollbarOldOnError = t), r.onerror = a } }, captureUnhandledRejections: function (r, e, o) { if (r) { "function" == typeof r._rollbarURH && r._rollbarURH.belongsToShim && r.removeEventListener("unhandledrejection", r._rollbarURH); var n = function (r) { var o, n, t; try { o = r.reason } catch (r) { o = void 0 } try { n = r.promise } catch (r) { n = "[unhandledrejection] error getting `promise` from event" } try { t = r.detail, !o && t && (o = t.reason, n = t.promise) } catch (r) { } o || (o = "[unhandledrejection] error getting `reason` from event"), e && e.handleUnhandledRejection && e.handleUnhandledRejection(o, n) }; n.belongsToShim = o, r._rollbarURH = n, r.addEventListener("unhandledrejection", n) } } } }, function (r, e, o) { "use strict"; function n(r, e, o) { if (e.hasOwnProperty && e.hasOwnProperty("addEventListener")) { for (var n = e.addEventListener; n._rollbarOldAdd && n.belongsToShim;)n = n._rollbarOldAdd; var t = function (e, o, t) { n.call(this, e, r.wrap(o), t) }; t._rollbarOldAdd = n, t.belongsToShim = o, e.addEventListener = t; for (var a = e.removeEventListener; a._rollbarOldRemove && a.belongsToShim;)a = a._rollbarOldRemove; var l = function (r, e, o) { a.call(this, r, e && e._rollbar_wrapped || e, o) }; l._rollbarOldRemove = a, l.belongsToShim = o, e.removeEventListener = l } } r.exports = function (r, e, o) { if (r) { var t, a, l = "EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(","); for (t = 0; t < l.length; ++t)r[a = l[t]] && r[a].prototype && n(e, r[a].prototype, o) } } }, function (r, e, o) { "use strict"; function n(r, e) { this.impl = r(e, this), this.options = e, function (r) { for (var e = function (r) { return function () { var e = Array.prototype.slice.call(arguments, 0); if (this.impl[r]) return this.impl[r].apply(this.impl, e) } }, o = "log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleAnonymousErrors,handleUnhandledRejection,_createItem,wrap,loadFull,shimId,captureEvent,captureDomContentLoaded,captureLoad".split(","), n = 0; n < o.length; n++)r[o[n]] = e(o[n]) }(n.prototype) } n.prototype._swapAndProcessMessages = function (r, e) { var o, n, t; for (this.impl = r(this.options); o = e.shift();)n = o.method, t = o.args, this[n] && "function" == typeof this[n] && ("captureDomContentLoaded" === n || "captureLoad" === n ? this[n].apply(this, [t[0], o.ts]) : this[n].apply(this, t)); return this }, r.exports = n }, function (r, e, o) { "use strict"; r.exports = function (r) { return function (e) { if (!e && !window._rollbarInitialized) { for (var o, n, t = (r = r || {}).globalAlias || "Rollbar", a = window.rollbar, l = function (r) { return new a(r) }, i = 0; o = window._rollbarShims[i++];)n || (n = o.handler), o.handler._swapAndProcessMessages(l, o.messages); window[t] = n, window._rollbarInitialized = !0 } } } }]);
    // End Rollbar Snippet</script><script defer="defer" src="52748003802fa3225978.js"></script></head><body><div class="ivsHolder" style="position:absolute; top:0; width:100%; height:100%;"><video id="ivsVideo" class="" playsinline autoplay></video><div id="ivsFade"></div></div><div style="display:hidden;" id="audios"></div><div style="display:hidden;" id="videos"></div><video class="hexagonVideo" id="hexVideo" autoplay muted playsinline></video><script src="https://player.live-video.net/1.13.0/amazon-ivs-player.min.js"></script></body><style>body,
  html {
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
    font-family: arial;
    color: white;
    background-color: transparent;
    font-size: 10pt;
    background-color: #0D1133;
  }

  #renderCanvas {
    width: 100%;
    height: 100%;
    touch-action: none;
    position: absolute;
    top: 0;
    left: 0;
    outline: none;
    z-index: 3;
  }

  /* Enlarge font for phones in portrait*/
  @media only screen and (max-device-width: 926px) and (orientation: portrait) {
    body {
      font-size: 14pt;
    }
  }

  .hexagonVideo {
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    width: 192px;
    height: 221px;
    background-color: transparent;
    position: absolute;
    z-index: 5;
    top: 40px;
    left: 30px;
    object-fit: cover;
    transform: scaleX(-1);
  }

  .hexagonVideo.notch {
    top: 90px;
  }

  #ivsVideo {
    width: 100%;
    height: 65%;
    object-fit: cover;
  }

  #ivsVideo.full {
    height: 100%;
  }

  #ivsFade {
    position: absolute;
    width: 100%;
    height: 9%;
    top: 57%;
    z-index: 2;
    background-image: linear-gradient(rgba(14, 16, 49, 0), rgba(14, 16, 49, 255));
  }

  #ivsVideo.right {
    object-fit: cover;
    transform: rotate(90deg);
    transform-origin: bottom left;
    position: absolute;
    top: -100vw;
    height: 100vw;
    width: 100vh;
  }

  #ivsVideo.left {
    object-fit: cover;
    transform: rotate(-90deg);
    transform-origin: top left;
    position: absolute;
    top: 178vw;
    height: 100vw;
    width: 100vh;
  }



  .hidden {
    display: none;
  }</style><script>window.cs = {};

  window.cs.masterVolume = 1;
  window.cs.release = 1000;
  window.cs.dip = 10;
  window.cs.floor = 0;
  window.cs.dwell = 2000;
  window.cs.dipping = false;


  const dipAudio = () => {
    //looks at the past 2048 samples to find the peak volume per user
    //dips the (show) audio in inverse proportion to the average of those peaks

    // console.log("dip")
    let tMax = 0;
    if (window.cs.watchAudioLevels.length && !window.cs.dipping) {

      let tMax = 0 //total of all peak volumes
      let loudest = 0
      for (let i = 0; i < window.cs.watchAudioLevels.length; i++) {
        a = window.cs.watchAudioLevels[i];
        a.getByteTimeDomainData(window.cs.samples);
        tMax += Math.max(...window.cs.samples) - 128;  //using the spread operator (is much clearer than array.reduce()), samples are offset by 128

        //dominanat speaker - take the sum over the last 50 or so samples -
        const sum = window.cs.samples.reduce((a, v) => a + v) //there is an implicit return in the arrow function here 
        if (sum > loudest) { loudest = sum; window.cs.dominantSpeaker = i }  //The index may not be a fat lot of use to you - discuss...
        // window.cs.traces[i + 1].push(tMax)  //Push the mAximum volume of this speaker, during it into the traces for grphing

      }
    }

    if (window.cs.dipme) {
      window.cs.showVolume.gain.value = 0.1;
    }

    else if (tMax > 0) {
      window.cs.dipping = true;
      window.cs.showVolume.gain.value = 0;
      setTimeout(() => {
        window.cs.dipping = false;
      }, 500)
    } else {
      window.cs.showVolume.gain.value = 0.4;
    }

    // const aMax = tMax / window.cs.watchAudioLevels.length;  //average maximum volume (so dipping is proportional to the total hubbub)

    // const dipFactor = window.cs.dip  //how strong should the dipping effect be (0.5-2 ish)

    // let newVolume = 1 - ((aMax / 128) * dipFactor)   //new target volume for the show to 1- average peak (of speakers - voume in t)  

    // if (newVolume < window.cs.floor) { //clamp at the floor
    //   newVolume = window.cs.floor
    // }

    // let csv = window.cs.showVolume.gain.value //current show volume (read it off the audio gain node)

    // console.log('newVolume', newVolume, csv);

    // // window.cs.traces[0].push(csv * 128) //push the current show volume into trace 0

    // // graphVolumes()
    // if (newVolume <= csv) {  //this is confusing (but correct) the newVolume is the DIPPED volume, some louder speakers = more dipping = smaller volume
    //   //people are talking louder.. (instantly) push the show volume down more

    //   csv = newVolume
    //   window.cs.quietTime = null

    // }
    // else {

    //   //The talkers have gone quiet (or at least stopped getting louder), 
    //   if (!window.cs.quietTime) { cs.quietTime = performance.now(); window.cs.deepest = csv }
    //   const t = (performance.now() - window.cs.quietTime)  //elapsed time in MS since it first went quiet
    //   if (t > window.cs.dwell) { //have we passed the 'dwell' (silence hold down) time

    //     if (t < window.cs.dwell + window.cs.release) {

    //       let a = (1 - window.cs.deepest)  //amout
    //       let f = ((t - window.cs.dwell) / window.cs.release)  //of time					
    //       let s = (1 + Math.sin((f + 1.5) * Math.PI)) / 2   //generate a 'S' the a sin wave (phase shifted, 1.5*PI ) +1 and /2 to 'normalise' into 0-1 range
    //       s *= a  //multipy by the depth we want to recover from					
    //       csv = window.cs.deepest + s
    //     }
    //     else {
    //       csv = 1
    //     }
    //   }
    // }


    // window.cs.showVolume.gain.value = csv  //write the new value back to the audio node

    //window.cs.masterVolume is bound to a slider ... showMaster is the gain node itself

  }



  function attachAnalyser(element) {
    //NOT THIS - const localSrc=window.cs.actx.createMediaElementSource(hexVideo);
    console.log('attaching ananlyser', element);
    const localSrc = window.cs.actx.createMediaStreamSource(element.srcObject);
    const analyser = window.cs.actx.createAnalyser() // new AnalyserNode(window.cs.actx)    
    analyser.fftSize = 2048

    localSrc.connect(analyser)

    window.cs.watchAudioLevels.push(analyser);
    console.log(`Attached analyser to ${element.id}`)
    window.Rollbar.debug(`Attached analyser to ${element.id}`);

  }

  window.attachAnalyser = attachAnalyser;

  // window.startIVS = () => {
  if (IVSPlayer.isPlayerSupported) {
    const player = IVSPlayer.create();
    const videoElement = document.getElementById("ivsVideo");
    player.attachHTMLVideoElement(videoElement);

    // demo ivs stream 
    // player.load('https://fcc3ddae59ed.us-west-2.playback.live-video.net/api/video/v1/us-west-2.893648527354.channel.DmumNckWFTqz.m3u8');
    // kylie
    player.load('https://62b0e484537e.eu-west-1.playback.live-video.net/api/video/v1/eu-west-1.743551506018.channel.eyBFCGdNC6ZL.m3u8');

    // window.cs.actx = new AudioContext()  //An audioContext
    // window.cs.samples = new Uint8Array(2048); //buffer is reused accross all analysers
    // window.cs.watchAudioLevels = []  // an array of analyserNodes (which moitor the volument of speakers) - initialise in 

    const localVideo = document.getElementById("hexVideo")
    // don't attach local video to prevent pumping
    // attachAnalyser(localVideo)

    //create a gain nodes for the main show
    // const actx = window.cs.actx; //get a reference to the context we created at startup (in the app constructor)
    // const src = actx.createMediaElementSource(videoElement)

    // const showVolume = new GainNode(window.cs.actx)       ////this is the AutoDipper show volume node
    // showVolume.gain.value = 0;
    // src.connect(showVolume) //connect the source audio to the volume control
    // window.cs.showVolume = showVolume

    // const showMaster = new GainNode(actx)
    // showVolume.connect(showMaster) //connect the volume control into the master control
    // showMaster.connect(actx.destination) //connect the master control to the 'speakers'
    // showMaster.gain.value = window.cs.masterVolume  //This is a second volume control for hte show ... independent of speakers)
    // window.cs.showMaster = showMaster //provide access to dipAudio

    // setInterval(dipAudio, 50) //50ms = 20 times per second

    player.play();
    window.cs.ivs = player;

  }


  // push camera view down if there is a notch

  var url = new URL(window.location);
  var notch = url.searchParams.get("notch");
  var live = url.searchParams.get("live");


  if (notch === 'true' || notch === true || notch === 1) {
    document.getElementById("hexVideo").classList.add('notch');
  }

  if (live === 'true' || live === true || live === 1) {
    window.liveMode = true;
  }</script></html>